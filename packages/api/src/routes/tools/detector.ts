import { generateText } from '../../lib/ai-client';
import { encryptData, decryptData } from '@repo/database/lib/encryption';
import { createDetectorUsage, getDetectorUsageByUserId, deleteDetectorUsage } from '@repo/database';
import { Hono } from 'hono';
import { describeRoute } from 'hono-openapi';
import { resolver, validator } from 'hono-openapi/zod';
import { HTTPException } from 'hono/http-exception';
import { z } from 'zod';
import { authMiddleware } from '../../middleware/auth';
import { buildDetectorPrompt } from '../../lib/prompt-templates';
import { DetectorInputSchema, preprocessInput } from '../../lib/input-validation';
import { validateAndEnforceLimit } from '../../lib/word-limit-middleware';

const DetectResponseSchema = z.object({
  aiProbability: z.number().min(0).max(1),
  detectionResult: z.enum(['Human', 'AI', 'Mixed']),
  wordCount: z.number(),
  charactersUsed: z.number(),
  creditsUsed: z.number().optional(),
  confidence: z.string(),
  analysis: z.object({
    reasoning: z.string(),
    indicators: z.object({
      vocabulary: z.object({
        score: z.number().min(0).max(100),
        issues: z.array(z.string()),
        explanation: z.string()
      }),
      syntax: z.object({
        score: z.number().min(0).max(100),
        issues: z.array(z.string()),
        explanation: z.string()
      }),
      coherence: z.object({
        score: z.number().min(0).max(100),
        issues: z.array(z.string()),
        explanation: z.string()
      }),
      creativity: z.object({
        score: z.number().min(0).max(100),
        issues: z.array(z.string()),
        explanation: z.string()
      })
    }),
    suggestions: z.array(z.string())
  })
});

export const detectorRouter = new Hono()
  .basePath('/tools/detector')
  .use(authMiddleware)
  .post(
    '/analyze',
    describeRoute({
      tags: ['Tools'],
      summary: 'Detect AI-generated content',
      description: 'Analyze text to determine if it was generated by AI',
      responses: {
        200: {
          description: 'AI detection results',
          content: {
            'application/json': {
              schema: resolver(DetectResponseSchema)
            }
          }
        }
      }
    }),
    validator('json', DetectorInputSchema),
    async (c) => {
      const { inputText } = c.req.valid('json');
      const user = c.get('user');

      // Validate input and check word limits
      const validation = await validateAndEnforceLimit(user.id, inputText, 'detector');
      
      if (!validation.success) {
        throw new HTTPException(400, { 
          message: validation.message,
          cause: validation.error 
        });
      }
      
      // Preprocess and validate input
      const { cleanText, wordCount, characterCount, creditsRequired } = preprocessInput(inputText);

      const prompt = buildDetectorPrompt(cleanText);

      try {
        // Call AI model to detect AI content
        const response = await generateText({
          prompt,
          maxTokens: 1000
        });

        // Parse JSON response
        const responseText = response.text.trim();
        let analysisData: any;
        
        try {
          // Extract JSON from response if it's wrapped in other text
          const jsonMatch = responseText.match(/\{[\s\S]*\}/);
          const jsonString = jsonMatch ? jsonMatch[0] : responseText;
          analysisData = JSON.parse(jsonString);
        } catch (parseError) {
          console.error('Failed to parse JSON response:', parseError, 'Response:', responseText);
          throw new HTTPException(500, { message: 'Failed to parse analysis results' });
        }
        
        const detectionResult = (analysisData.likelihood as 'Human' | 'AI' | 'Mixed') || 'Mixed';
        const confidence = analysisData.confidence || 'Low';

        // Convert to probability for consistency
        let aiProbability: number;
        if (detectionResult === 'AI') {
          aiProbability = confidence === 'High' ? 0.9 : confidence === 'Medium' ? 0.7 : 0.6;
        } else if (detectionResult === 'Mixed') {
          aiProbability = 0.5;
        } else { // Human
          aiProbability = confidence === 'High' ? 0.1 : confidence === 'Medium' ? 0.3 : 0.4;
        }

        // Build analysis object with fallbacks
        const analysis = {
          reasoning: analysisData.reasoning || 'Analysis could not be completed',
          indicators: {
            vocabulary: {
              score: analysisData.vocabulary?.score || 50,
              issues: analysisData.vocabulary?.issues || [],
              explanation: analysisData.vocabulary?.explanation || 'No specific vocabulary analysis available'
            },
            syntax: {
              score: analysisData.syntax?.score || 50,
              issues: analysisData.syntax?.issues || [],
              explanation: analysisData.syntax?.explanation || 'No specific syntax analysis available'
            },
            coherence: {
              score: analysisData.coherence?.score || 50,
              issues: analysisData.coherence?.issues || [],
              explanation: analysisData.coherence?.explanation || 'No specific coherence analysis available'
            },
            creativity: {
              score: analysisData.creativity?.score || 50,
              issues: analysisData.creativity?.issues || [],
              explanation: analysisData.creativity?.explanation || 'No specific creativity analysis available'
            }
          },
          suggestions: analysisData.suggestions || []
        };

        // Encrypt sensitive content before storing
        const encryptedContent = encryptData(JSON.stringify({
          inputText: cleanText
        }));

        // Save usage to database
        await createDetectorUsage({
          user: { connect: { id: user.id } },
          encryptedContent: JSON.stringify(encryptedContent),
          aiProbability,
          detectionResult,
          wordCount,
          charactersUsed: characterCount,
          creditsUsed: creditsRequired,
          expiresAt: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000) // 30 days
        });

        return c.json({
          aiProbability,
          detectionResult,
          wordCount,
          charactersUsed: characterCount,
          creditsUsed: creditsRequired,
          confidence,
          analysis
        });
      } catch (error) {
        console.error('Detector error:', error);
        throw new HTTPException(500, { message: 'Failed to analyze text' });
      }
    }
  )
  .get(
    '/history',
    describeRoute({
      tags: ['Tools'],
      summary: 'Get detector usage history',
      description: 'Retrieve recent detector usage for the current user',
      responses: {
        200: {
          description: 'Usage history',
          content: {
            'application/json': {
              schema: resolver(z.object({
                history: z.array(z.object({
                  id: z.string(),
                  aiProbability: z.number(),
                  detectionResult: z.string(),
                  wordCount: z.number(),
                  charactersUsed: z.number(),
                  creditsUsed: z.number().nullable(),
                  createdAt: z.date(),
                  inputText: z.string()
                }))
              }))
            }
          }
        }
      }
    }),
    validator('query', z.object({
      limit: z.string().transform(Number).pipe(z.number().min(1).max(50)).optional().default('10')
    }).optional()),
    async (c) => {
      const query = c.req.valid('query');
      const user = c.get('user');
      const limit = query?.limit || 10;

      const usageRecords = await getDetectorUsageByUserId({
        userId: user.id,
        limit
      });

      const history = usageRecords.map(record => {
        // Decrypt content
        const encryptedData = JSON.parse(record.encryptedContent);
        const decryptedContent = JSON.parse(decryptData(encryptedData));
        
        return {
          id: record.id,
          aiProbability: record.aiProbability,
          detectionResult: record.detectionResult,
          wordCount: record.wordCount,
          charactersUsed: record.charactersUsed,
          creditsUsed: record.creditsUsed,
          createdAt: record.createdAt,
          inputText: decryptedContent.inputText
        };
      });

      return c.json({ history });
    }
  )
  .delete(
    '/history/:id',
    describeRoute({
      tags: ['Tools'],
      summary: 'Delete detector history item',
      description: 'Delete a specific detector history entry by ID',
      responses: {
        204: {
          description: 'History item deleted successfully'
        },
        404: {
          description: 'History item not found'
        }
      }
    }),
    async (c) => {
      const { id } = c.req.param();
      const user = c.get('user');

      const result = await deleteDetectorUsage(id, user.id);
      
      if (result.count === 0) {
        throw new HTTPException(404, { message: 'History item not found' });
      }

      return c.body(null, 204);
    }
  );